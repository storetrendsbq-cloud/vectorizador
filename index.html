<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vectorizador profesional (Potrace WASM) - Sublimación</title>
  <meta name="description" content="App simple para vectorizar imágenes en el navegador usando Potrace (wasm). Lista para GitHub Pages." />
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa4b2;--accent:#06b6d4}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Helvetica,Arial}
    body{background:linear-gradient(180deg,#071028 0%, #071826 100%);color:#e6eef6;padding:24px}
    .container{max-width:1100px;margin:0 auto}
    header{display:flex;align-items:center;gap:16px}
    h1{font-size:20px;margin:0}
    .card{background:rgba(255,255,255,0.02);padding:16px;border-radius:12px;margin-top:16px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .grid{display:grid;grid-template-columns:320px 1fr;gap:16px}
    .controls label{display:block;margin-top:8px;font-size:13px;color:var(--muted)}
    input[type=file]{width:100%}
    .preview{display:flex;flex-direction:column;gap:8px}
    canvas, img#sourceImage{max-width:100%;border-radius:8px;background:#fff}
    #svgPreview{background:#fff;padding:8px;border-radius:8px;min-height:200px}
    .row{display:flex;gap:8px;align-items:center}
    button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#012;cursor:pointer}
    button:disabled{opacity:0.4;cursor:not-allowed}
    .muted{color:var(--muted);font-size:13px}
    footer{margin-top:18px;color:var(--muted);font-size:13px}
    .inline-input{width:72px}
    .small{font-size:12px}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='38' height='38'><rect rx='6' width='38' height='38' fill='%2306b6d4'/><text x='50%' y='54%' font-size='16' font-family='Arial' fill='white' text-anchor='middle' dominant-baseline='middle'>V</text></svg>" alt="logo" width="48" height="48">
      <div>
        <h1>Vectorizador para Sublimación — Potrace (WASM)</h1>
        <div class="muted">Genera SVGs listos para impresión; exporta PNG a 300 DPI. (Revisa licencia Potrace antes de distribuir)</div>
      </div>
    </header>

    <div class="card grid">
      <div class="controls">
        <label>1) Selecciona una imagen (jpg, png, webp)</label>
        <input id="fileInput" type="file" accept="image/*" />

        <label class="small">Preview (imagen subida)</label>
        <div class="preview card" style="padding:10px">
          <img id="sourceImage" alt="preview" style="display:none;max-height:360px;object-fit:contain"/>
          <canvas id="previewCanvas" style="display:none;max-width:100%"></canvas>
          <div id="imageInfo" class="muted small">No hay imagen cargada</div>
        </div>

        <label>2) Parámetros de vectorización</label>
        <label class="small">Umbral (threshold) <span id="thresholdVal">50</span></label>
        <input id="threshold" type="range" min="0" max="100" value="50" />

        <label class="small">Suavizado (smoothness) <span id="smoothVal">50</span></label>
        <input id="smoothness" type="range" min="0" max="100" value="50" />

        <label><input id="removeBg" type="checkbox" /> Remover fondo transparente (tratar como blanco)</label>
        <label><input id="optimizePaths" type="checkbox" /> Optimizar SVG (limpiar trazados)</label>

        <div style="margin-top:12px">
          <button id="vectorizeBtn">Vectorizar</button>
          <button id="clearBtn" style="background:#334155;color:#e6eef6">Limpiar</button>
        </div>

        <div style="margin-top:12px" class="muted small">Consejo: si la imagen es fotográfica y quieres colores, usa posterize/multicolor (próxima versión).</div>
      </div>

      <div>
        <div class="row" style="justify-content:space-between;align-items:center">
          <div class="muted small">Resultado vectorizado</div>
          <div class="row">
            <button id="downloadSvg" disabled>Descargar SVG</button>
            <button id="exportPng" disabled>Exportar PNG (300 DPI)</button>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div id="svgPreview">Aquí aparecerá el SVG resultante</div>
        </div>

        <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
          <label class="small">Ancho (pulg): <input id="pngWidthIn" class="inline-input" type="number" step="0.1" value="12"></label>
          <label class="small">Alto (pulg): <input id="pngHeightIn" class="inline-input" type="number" step="0.1" value="12"></label>
          <label class="small">DPI: <input id="pngDpi" class="inline-input" type="number" value="300"></label>
        </div>

        <div style="margin-top:8px;color:var(--muted);font-size:13px">Tamaño SVG: <span id="svgSize">0 KB</span> — Paths: <span id="pathsCount">0</span></div>
      </div>
    </div>

    <footer class="muted">Instrucciones rápidas y despliegue: copia el archivo <code>index.html</code> en la raíz de tu repo GitHub, publica con GitHub Pages (branch main) y ya estará disponible. <strong>Revisa la licencia de Potrace (GPL v2).</strong></footer>

  </div>

  <script type="module">
    // IMPORT: ESM build of Potrace WASM (browser). Uses the 'esm-potrace-wasm' ESM package.
    // Nota: la librería está licenciada GPLv2. Si vas a redistribuir/poner el proyecto público, revisa obligaciones de licencia.
    import { init as potraceInit, potrace } from 'https://cdn.jsdelivr.net/npm/esm-potrace-wasm@0.4.1/dist/index.js';

    // UI elements
    const fileInput = document.getElementById('fileInput');
    const sourceImage = document.getElementById('sourceImage');
    const previewCanvas = document.getElementById('previewCanvas');
    const imageInfo = document.getElementById('imageInfo');
    const thresholdSlider = document.getElementById('threshold');
    const thresholdVal = document.getElementById('thresholdVal');
    const smoothSlider = document.getElementById('smoothness');
    const smoothVal = document.getElementById('smoothVal');
    const removeBg = document.getElementById('removeBg');
    const optimizePaths = document.getElementById('optimizePaths');
    const vectorizeBtn = document.getElementById('vectorizeBtn');
    const clearBtn = document.getElementById('clearBtn');
    const svgPreview = document.getElementById('svgPreview');
    const downloadSvgBtn = document.getElementById('downloadSvg');
    const exportPngBtn = document.getElementById('exportPng');
    const pngWidthIn = document.getElementById('pngWidthIn');
    const pngHeightIn = document.getElementById('pngHeightIn');
    const pngDpi = document.getElementById('pngDpi');
    const svgSizeSpan = document.getElementById('svgSize');
    const pathsCountSpan = document.getElementById('pathsCount');

    let lastSvg = '';
    let loadedImage = null;

    // Bind UI
    thresholdSlider.addEventListener('input', ()=> thresholdVal.textContent = thresholdSlider.value);
    smoothSlider.addEventListener('input', ()=> smoothVal.textContent = smoothSlider.value);

    fileInput.addEventListener('change', handleFile);
    clearBtn.addEventListener('click', clearAll);
    vectorizeBtn.addEventListener('click', vectorizeImage);
    downloadSvgBtn.addEventListener('click', downloadSvg);
    exportPngBtn.addEventListener('click', exportPngFromSvg);

    // Initialize Potrace WASM module (asynchronous)
    let potraceReady = false;
    (async ()=>{
      try {
        await potraceInit();
        potraceReady = true;
        console.log('Potrace WASM inicializado');
      } catch (err) {
        console.error('Error inicializando Potrace WASM:', err);
        alert('Error cargando motor de vectorización (Potrace). Revisa la consola.');
      }
    })();

    function handleFile(e){
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = function(ev){
        sourceImage.src = ev.target.result;
        sourceImage.style.display = 'block';
        sourceImage.onload = function(){
          loadedImage = sourceImage;
          // Draw to preview canvas (scaled)
          drawPreviewCanvas(sourceImage);
          imageInfo.textContent = `${sourceImage.naturalWidth}×${sourceImage.naturalHeight} px — ${Math.round(f.size/1024)} KB`;
        };
      };
      reader.readAsDataURL(f);
    }

    function drawPreviewCanvas(img){
      const maxDim = 2500; // limitar para evitar bloquear el navegador
      const w = img.naturalWidth;
      const h = img.naturalHeight;
      let scale = 1;
      if (Math.max(w,h) > maxDim) scale = maxDim/Math.max(w,h);
      previewCanvas.width = Math.round(w*scale);
      previewCanvas.height = Math.round(h*scale);
      const ctx = previewCanvas.getContext('2d');
      ctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
      ctx.drawImage(img,0,0, previewCanvas.width, previewCanvas.height);
      previewCanvas.style.display = 'block';
    }

    function clearAll(){
      sourceImage.src = '';
      sourceImage.style.display = 'none';
      previewCanvas.style.display = 'none';
      imageInfo.textContent = 'No hay imagen cargada';
      svgPreview.innerHTML = 'Aquí aparecerá el SVG resultante';
      downloadSvgBtn.disabled = true;
      exportPngBtn.disabled = true;
      lastSvg = '';
    }

    async function vectorizeImage(){
      if (!loadedImage) { alert('Carga primero una imagen'); return; }
      if (!potraceReady) { alert('El motor Potrace aún no está listo. Intenta en unos segundos.'); return; }

      // Mostrar estado
      vectorizeBtn.disabled = true;
      vectorizeBtn.textContent = 'Vectorizando...';

      try {
        // Preparar canvas binario
        const maxDim = 3000;
        const w0 = loadedImage.naturalWidth;
        const h0 = loadedImage.naturalHeight;
        let scale = 1;
        if (Math.max(w0,h0) > maxDim) scale = maxDim/Math.max(w0,h0);
        const cw = Math.round(w0*scale);
        const ch = Math.round(h0*scale);

        const tmp = document.createElement('canvas');
        tmp.width = cw;
        tmp.height = ch;
        const tctx = tmp.getContext('2d');

        // Dibujar imagen original (respetando tamaño)
        tctx.drawImage(loadedImage, 0, 0, cw, ch);

        // Binarizar según umbral (0-100)
        const threshold = parseInt(thresholdSlider.value,10);
        const t255 = Math.round((threshold/100)*255);
        const data = tctx.getImageData(0,0,cw,ch);
        for (let i=0;i<data.data.length;i+=4){
          const r = data.data[i], g = data.data[i+1], b = data.data[i+2], a = data.data[i+3];
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;
          if (removeBg.checked && a < 250) {
            // tratar como fondo blanco
            data.data[i]=data.data[i+1]=data.data[i+2]=255;
            data.data[i+3]=255;
            continue;
          }
          if (lum < t255) { data.data[i]=data.data[i+1]=data.data[i+2]=0; data.data[i+3]=255; }
          else { data.data[i]=data.data[i+1]=data.data[i+2]=255; data.data[i+3]=255; }
        }
        tctx.putImageData(data,0,0);

        // Map UI smoothness to turdsize/opttolerance
        const smooth = parseInt(smoothSlider.value,10);
        const turdsize = Math.round((100 - smooth) * 0.6); // heurístico
        const opttolerance = Math.max(0.01, (smooth/100)*0.35);
        const alphamax = 1.0; // default

        // Llamar a potrace (acepta canvas)
        const options = {
          turdsize: turdsize,
          opttolerance: opttolerance,
          alphamax: alphamax,
          // no posterize porque ya binarizamos
          posterizelevel: 1,
          extractcolors: false,
          pathonly: false
        };

        // Ejecutar la traza
        const svg = await potrace(tmp, options);
        if (!svg || svg.length < 10) throw new Error('SVG vacío devuelto por Potrace');

        // optimización ligera si está marcada
        lastSvg = optimizeSvg(svg, optimizePaths.checked);

        svgPreview.innerHTML = lastSvg;
        svgSizeSpan.textContent = (new Blob([lastSvg]).size/1024).toFixed(2) + ' KB';
        pathsCountSpan.textContent = (lastSvg.match(/<path\b/g) || []).length;

        // Habilitar botones
        downloadSvgBtn.disabled = false;
        exportPngBtn.disabled = false;

      } catch (err) {
        console.error('Error vectorizando:', err);
        alert('Error durante la vectorización. Revisa la consola.');
      } finally {
        vectorizeBtn.disabled = false;
        vectorizeBtn.textContent = 'Vectorizar';
      }
    }

    function optimizeSvg(svgText, doOptimize){
      if (!doOptimize) return svgText;
      let s = svgText;
      s = s.replace(/<!--([\s\S]*?)-->/g,'');
      s = s.replace(/<g[^>]*>\s*<\/g>/g,'');
      s = s.replace(/\s{2,}/g,' ');
      return s;
    }

    function downloadSvg(){
      if (!lastSvg) return;
      const blob = new Blob([lastSvg], {type:'image/svg+xml'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'design.svg';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Exporta SVG a PNG usando canvas a la dimensión (pulgadas x DPI)
    function exportPngFromSvg(){
      if (!lastSvg) { alert('No hay SVG para exportar'); return; }
      const widthIn = parseFloat(pngWidthIn.value) || 12;
      const heightIn = parseFloat(pngHeightIn.value) || 12;
      const dpi = parseInt(pngDpi.value,10) || 300;
      exportSvgToPng(lastSvg, widthIn, heightIn, dpi, `design_${widthIn}x${heightIn}_${dpi}dpi.png`);
    }

    function exportSvgToPng(svgText, widthInches, heightInches, dpi, filename){
      const pxW = Math.round(widthInches * dpi);
      const pxH = Math.round(heightInches * dpi);

      // Ensure svg has viewBox; if not, set width/height
      let svgForExport = svgText;
      if (!/viewBox/.test(svgText)){
        // try to inject viewBox="0 0 W H" where W/H are current preview sizes (fallback)
        const match = svgText.match(/<svg[^>]*width=\"?([\d.]+)\"?[^>]*height=\"?([\d.]+)\"?/i);
        if (match) {
          const w = match[1], h = match[2];
          svgForExport = svgText.replace('<svg', `<svg viewBox=\"0 0 ${w} ${h}\" width=\"${pxW}\" height=\"${pxH}\"`);
        } else {
          svgForExport = svgText.replace('<svg', `<svg viewBox=\"0 0 ${pxW} ${pxH}\" width=\"${pxW}\" height=\"${pxH}\"`);
        }
      } else {
        // add width/height attributes to scale properly on canvas
        svgForExport = svgText.replace('<svg', `<svg width=\"${pxW}\" height=\"${pxH}\"`);
      }

      const blob = new Blob([svgForExport], {type:'image/svg+xml;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = function(){
        const canvas = document.createElement('canvas');
        canvas.width = pxW;
        canvas.height = pxH;
        const ctx = canvas.getContext('2d');
        // Fondo blanco opcional (sublimación sobre blanco preferible en muchas máquinas)
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img,0,0, canvas.width, canvas.height);
        canvas.toBlob(function(b){
          const a = document.createElement('a');
          a.href = URL.createObjectURL(b);
          a.download = filename || 'design.png';
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        }, 'image/png', 1.0);
      };
      img.onerror = function(e){
        console.error('Error cargando SVG para export:', e);
        alert('No se pudo rasterizar el SVG. Revisa la consola.');
        URL.revokeObjectURL(url);
      };
      img.src = url;
    }

  </script>

</body>
</html>
